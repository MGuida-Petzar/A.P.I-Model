<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>A.P.I-Model</title>
  <style>
    html,body { height:100%; margin:0; background:#111; }
    canvas { display:block; width:100%; height:100vh; }
  </style>

  <!-- Import map must appear before module scripts that use bare specifiers -->
  <script type="importmap">
  {
    "imports": {
      "three": "https://cdn.jsdelivr.net/npm/three@0.144.0/build/three.module.js"
    }
  }
  </script>
</head>
<body>
  <canvas id="canvas"></canvas>

  <script type="module">
    import * as THREE from 'three';
    import { GLTFLoader } from 'https://cdn.jsdelivr.net/npm/three@0.144.0/examples/jsm/loaders/GLTFLoader.js';
    import { OrbitControls } from 'https://cdn.jsdelivr.net/npm/three@0.144.0/examples/jsm/controls/OrbitControls.js';

    const canvas = document.getElementById('canvas');
    const renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
    renderer.setPixelRatio(window.devicePixelRatio || 1);
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.outputEncoding = THREE.sRGBEncoding; // nicer colors for glTF
    renderer.toneMapping = THREE.ACESFilmicToneMapping;
    renderer.toneMappingExposure = 1.0;
    renderer.shadowMap.enabled = true;
    renderer.shadowMap.type = THREE.PCFSoftShadowMap;

    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x0b0b0b);

    const camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.set(0, 1.6, 3);

    // Controls
    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.dampingFactor = 0.06;
    controls.screenSpacePanning = false;
    controls.minDistance = 0.1;
    controls.maxDistance = 200;

    // Lighting: ambient + hemisphere + directional (for nice shading)
    const ambient = new THREE.AmbientLight(0xffffff, 0.45);
    scene.add(ambient);

    const hemi = new THREE.HemisphereLight(0xffffee, 0x111122, 0.35);
    scene.add(hemi);

    const dir = new THREE.DirectionalLight(0xffffff, 1.0);
    dir.position.set(5, 10, 7.5);
    dir.castShadow = true;
    dir.shadow.mapSize.set(2048, 2048);
    dir.shadow.camera.near = 0.5;
    dir.shadow.camera.far = 500;
    scene.add(dir);

    // Optional ground for shadow catch and reference
    const groundMat = new THREE.MeshStandardMaterial({ color: 0x222222, metalness: 0, roughness: 1 });
    const ground = new THREE.Mesh(new THREE.PlaneGeometry(200, 200), groundMat);
    ground.rotation.x = - Math.PI / 2;
    ground.position.y = -1.0;
    ground.receiveShadow = true;
    scene.add(ground);

    // Loader and model auto-fit
    const loader = new GLTFLoader();

    // Use the working raw URL you confirmed earlier:
    const modelUrl = 'https://mguida-petzar.github.io/A.P.I-Model/new-folder/Project%20API.glb';
    // (Or use your GitHub Pages URL if that works:
    // const modelUrl = 'https://mguida-petzar.github.io/A.P.I-Model/models/myModel.glb';
    // )

    loader.load(
      modelUrl,
      (gltf) => {
        const model = gltf.scene;
        model.traverse((n) => {
          if (n.isMesh) {
            n.castShadow = true;
            n.receiveShadow = true;
            // If lighting still looks wrong you can try:
            // n.material.side = THREE.DoubleSide;
            // n.material.needsUpdate = true;
          }
        });

        scene.add(model);

        // Compute bounding box and frame camera
        const box = new THREE.Box3().setFromObject(model);
        const size = box.getSize(new THREE.Vector3());
        const center = box.getCenter(new THREE.Vector3());

        // Reposition model so its center is at the origin (optional)
        model.position.x += (model.position.x - center.x);
        model.position.y += (model.position.y - center.y);
        model.position.z += (model.position.z - center.z);

        // Frame camera: compute a distance so model fits in view
        const maxDim = Math.max(size.x, size.y, size.z);
        const fov = camera.fov * (Math.PI / 180);
        let cameraZ = Math.abs(maxDim / 2 / Math.tan(fov / 2));
        cameraZ *= 1.5; // add some margin
        camera.position.set(center.x, center.y + maxDim * 0.3, center.z + cameraZ);

        camera.near = Math.max(0.1, cameraZ / 1000);
        camera.far = cameraZ * 10;
        camera.updateProjectionMatrix();

        controls.target.copy(center);
        controls.update();

        console.log('Model loaded, size:', size, 'center:', center);
      },
      (xhr) => {
        if (xhr.lengthComputable) {
          console.log(`Model ${(xhr.loaded / xhr.total * 100).toFixed(1)}% loaded`);
        }
      },
      (err) => {
        console.error('GLTF load error:', err);
      }
    );

    // Small helper object so you can confirm controls are working (optional)
    const axes = new THREE.AxesHelper(0.5);
    scene.add(axes);

    function animate() {
      requestAnimationFrame(animate);
      controls.update();
      renderer.render(scene, camera);
    }
    animate();

    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });
  </script>
</body>
</html>
