<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>A.P.I Model - Fully Lit</title>
  <style>
    html,body { height:100%; margin:0; background:#0b0b0b; }
    canvas { display:block; width:100%; height:100vh; }

    /* GUI styling */
    .lil-gui {
      position: fixed !important;
      right: 28px;
      top: 28px;
      z-index: 10000;
      --background-color: rgba(18,18,18,0.85);
      --text-color: #fff;
      --title-background-color: #2a2a2a;
      --widget-color: #435d52;
      --hover-color: #557568;
      --focus-color: #6a8f80;
      --number-color: #a8f7b1;
      --string-color: #a8f7b1;
    }
  </style>

  <script type="importmap">
  {
    "imports": {
      "three": "https://cdn.jsdelivr.net/npm/three@0.144.0/build/three.module.js"
    }
  }
  </script>
</head>
<body>
  <canvas id="canvas"></canvas>

  <script type="module">
    import * as THREE from 'three';
    import { GLTFLoader } from 'https://cdn.jsdelivr.net/npm/three@0.144.0/examples/jsm/loaders/GLTFLoader.js';
    import { OrbitControls } from 'https://cdn.jsdelivr.net/npm/three@0.144.0/examples/jsm/controls/OrbitControls.js';
    import { RectAreaLightUniformsLib } from 'https://cdn.jsdelivr.net/npm/three@0.144.0/examples/jsm/lights/RectAreaLightUniformsLib.js';
    import GUI from 'https://cdn.jsdelivr.net/npm/lil-gui@0.18.0/dist/lil-gui.esm.min.js';

    // --- Renderer & scene setup ---
    const canvas = document.getElementById('canvas');
    const renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
    renderer.setPixelRatio(window.devicePixelRatio || 1);
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.outputEncoding = THREE.sRGBEncoding;
    renderer.toneMapping = THREE.ACESFilmicToneMapping;
    renderer.toneMappingExposure = 1.0; 
    renderer.shadowMap.enabled = false; // Disable shadows entirely
    renderer.physicallyCorrectLights = true;

    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x0b0b0b);

    const camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.01, 1000);
    camera.position.set(0, 1.6, 3);
    
    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;

    // --- FULL LIGHTING SETUP ---
    
    // 1. High Ambient Light (Base brightness everywhere)
    // Increased intensity from 1.2 to 2.5 for "fully lit" look
    const ambient = new THREE.AmbientLight(0xffffff, 2.5);
    scene.add(ambient);

    // 2. Strong Hemisphere Light (Sky/Ground fill)
    // Increased intensity from 0.6 to 1.5
    const hemi = new THREE.HemisphereLight(0xffffff, 0xbbbbbb, 1.5);
    scene.add(hemi);

    // 3. RectAreaLights (Soft studio fill, keeping these for nice reflections)
    RectAreaLightUniformsLib.init();
    const rectLights = [];
    const rectDefaults = { width: 3.0, height: 3.0, intensity: 5.0, radius: 2.0, elevation: 2.0 };
    
    for (let i = 0; i < 4; i++) {
      const rl = new THREE.RectAreaLight(0xffffff, rectDefaults.intensity, rectDefaults.width, rectDefaults.height);
      rl.lookAt(0,0,0);
      rectLights.push(rl);
      scene.add(rl);
    }

    // --- Loader ---
    const loader = new GLTFLoader();
    const modelUrl = 'https://mguida-petzar.github.io/A.P.I-Model/new-folder/Project%20API.glb';
    let loadedModel = null;
    let modelCenter = new THREE.Vector3(0, 0, 0);

    loader.load(
      modelUrl,
      (gltf) => {
        const model = gltf.scene;
        loadedModel = model;
        
        // Ensure materials are double sided and fully bright
        model.traverse(n => {
          if (n.isMesh) {
            n.castShadow = false;
            n.receiveShadow = false;
            if (n.material) {
                n.material.side = THREE.DoubleSide;
                n.material.needsUpdate = true;
            }
          }
        });

        scene.add(model);

        // Auto-center logic
        const box = new THREE.Box3().setFromObject(model);
        const size = box.getSize(new THREE.Vector3());
        modelCenter.copy(box.getCenter(new THREE.Vector3()));

        model.position.x += (model.position.x - modelCenter.x);
        model.position.y += (model.position.y - modelCenter.y);
        model.position.z += (model.position.z - modelCenter.z);

        const maxDim = Math.max(size.x, size.y, size.z);
        const fov = camera.fov * (Math.PI / 180);
        let cameraZ = Math.abs(maxDim / 2 / Math.tan(fov / 2));
        cameraZ *= 1.6;
        camera.position.set(modelCenter.x, modelCenter.y + maxDim * 0.35, modelCenter.z + cameraZ);
        
        camera.near = Math.max(0.01, cameraZ / 1000);
        camera.far = cameraZ * 10;
        camera.updateProjectionMatrix();
        
        controls.target.copy(modelCenter);
        controls.update();

        // Update rect lights to surround the model center
        updateRectLights();
      }
    );

    // --- GUI ---
    const params = {
      background: '#0b0b0b',
      exposure: 1.0,
      ambientIntensity: ambient.intensity,
      areaIntensity: rectDefaults.intensity
    };

    const gui = new GUI({ title: 'Settings' });
    
    gui.addColor(params, 'background').name('Background').onChange(v => scene.background.set(v));
    
    gui.add(params, 'exposure', 0, 5).name('Exposure').onChange(v => {
        renderer.toneMappingExposure = v;
    });

    gui.add(params, 'ambientIntensity', 0, 5).name('Ambient Light').onChange(v => {
        ambient.intensity = v;
    });

    gui.add(params, 'areaIntensity', 0, 20).name('Studio Lights').onChange(v => {
        rectLights.forEach(rl => rl.intensity = v);
    });

    // --- Helper Functions ---
    function updateRectLights() {
        const radius = rectDefaults.radius;
        const elevation = rectDefaults.elevation;
        const angles = [0, Math.PI / 2, Math.PI, (3 * Math.PI) / 2];
        
        for (let i = 0; i < rectLights.length; i++) {
            const a = angles[i];
            const rl = rectLights[i];
            rl.position.set(
                modelCenter.x + Math.cos(a) * radius,
                modelCenter.y + elevation,
                modelCenter.z + Math.sin(a) * radius
            );
            rl.lookAt(modelCenter);
        }
    }

    // --- Render Loop ---
    function animate() {
      requestAnimationFrame(animate);
      controls.update();
      renderer.render(scene, camera);
    }
    animate();

    // Resize handling
    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });
  </script>
</body>
</html>
