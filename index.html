<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>A.P.I-Model â€” Helpers All Around</title>
  <style>
    html,body { height:100%; margin:0; background:#0b0b0b; }
    canvas { display:block; width:100%; height:100vh; }

    /* GUI styling (Material-like) */
    .lil-gui, .dg {
      position: fixed !important;
      right: 28px;
      top: 28px;
      width: 220px !important;
      border-radius: 14px;
      overflow: visible !important;
      background: rgba(18,18,18,0.85);
      box-shadow: 0 12px 30px rgba(2,6,23,0.6);
      border: 6px solid #f7b1a8;
      z-index: 10000;
      padding: 8px;
      color: #fff;
      font-family: "Roboto", system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
    }
    .lil-gui .title, .dg .title { display: none !important; }
    .lil-gui .controller, .dg .controller {
      margin: 8px 4px; padding: 6px 10px; border-radius: 12px;
      background: linear-gradient(180deg, rgba(67,93,82,0.22), rgba(49,71,60,0.12));
      display:flex; align-items:center; justify-content:space-between; height:38px;
    }
    .lil-gui .label, .dg .label { color:#f2f6f3; font-weight:700; font-size:14px; text-transform:lowercase; }
    body { padding: 12px; }
  </style>

  <script type="importmap">
  {
    "imports": {
      "three": "https://cdn.jsdelivr.net/npm/three@0.144.0/build/three.module.js"
    }
  }
  </script>
</head>
<body>
  <canvas id="canvas"></canvas>

  <script type="module">
    import * as THREE from 'three';
    import { GLTFLoader } from 'https://cdn.jsdelivr.net/npm/three@0.144.0/examples/jsm/loaders/GLTFLoader.js';
    import { OrbitControls } from 'https://cdn.jsdelivr.net/npm/three@0.144.0/examples/jsm/controls/OrbitControls.js';
    import { RectAreaLightUniformsLib } from 'https://cdn.jsdelivr.net/npm/three@0.144.0/examples/jsm/lights/RectAreaLightUniformsLib.js';
    import GUI from 'https://cdn.jsdelivr.net/npm/lil-gui@0.18.0/dist/lil-gui.esm.min.js';

    // --- Renderer & scene setup ---
    const canvas = document.getElementById('canvas');
    const renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
    renderer.setPixelRatio(window.devicePixelRatio || 1);
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.outputEncoding = THREE.sRGBEncoding;
    renderer.toneMapping = THREE.ACESFilmicToneMapping;
    renderer.toneMappingExposure = 1.5;
    renderer.shadowMap.enabled = false;
    renderer.shadowMap.type = THREE.PCFSoftShadowMap;
    renderer.physicallyCorrectLights = true;

    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x0b0b0b);

    const camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.01, 1000);
    camera.position.set(0, 1.6, 3);
    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;

    // --- Even lighting baseline (ambient + hemi + 4 rect area lights) ---
    const ambient = new THREE.AmbientLight(0xffffff, 1.2);
    scene.add(ambient);

    const hemi = new THREE.HemisphereLight(0xffffff, 0xaaaaaa, 0.6);
    scene.add(hemi);

    RectAreaLightUniformsLib.init();
    const rectLights = [];
    // helpers arrays:
    const rectHelpers = [];    // translucent planes matching rect area lights
    let dirHelpers = [];       // arrow helpers for directional cluster (if created)

    const rectDefaults = { width: 2.6, height: 1.2, intensity: 3.0, radius: 1.2, elevation: 1.2 };
    for (let i = 0; i < 4; i++) {
      const rl = new THREE.RectAreaLight(0xffffff, rectDefaults.intensity, rectDefaults.width, rectDefaults.height);
      rl.castShadow = false;
      rectLights.push(rl);
      scene.add(rl);
    }

    // Directional cluster state
    let dirLights = [];
    let dirTargets = [];

    function createDirectionalCluster(count = 6, intensity = 0.6, distance = 5, elevation = 2.2) {
      removeDirectionalCluster();
      dirLights = [];
      dirTargets = [];
      for (let i = 0; i < count; i++) {
        const angle = (i / count) * Math.PI * 2;
        const x = Math.cos(angle) * distance;
        const z = Math.sin(angle) * distance;
        const y = elevation;
        const dl = new THREE.DirectionalLight(0xffffff, intensity);
        dl.position.set(x, y, z);
        dl.castShadow = false;
        const target = new THREE.Object3D();
        target.position.set(0, 0, 0);
        scene.add(target);
        dl.target = target;
        scene.add(dl);
        dirLights.push(dl);
        dirTargets.push(target);
      }
      // if helpers are currently enabled, create arrow helpers for the cluster
      if (params.showHelpers) addDirHelpers();
    }

    function removeDirectionalCluster() {
      removeDirHelpers();
      if (dirLights.length) {
        dirLights.forEach(dl => { if (dl.parent) dl.parent.remove(dl); });
        dirTargets.forEach(t => { if (t.parent) t.parent.remove(t); });
      }
      dirLights = [];
      dirTargets = [];
    }

    // --- Small axes helper ---
    const axes = new THREE.AxesHelper(0.5);
    axes.visible = false;
    scene.add(axes);

    // --- Loader + framing ---
    const loader = new GLTFLoader();
    const modelUrl = 'https://mguida-petzar.github.io/A.P.I-Model/new-folder/Project%20API.glb';

    let loadedModel = null;
    let modelCenter = new THREE.Vector3(0, 0, 0);

    loader.load(
      modelUrl,
      (gltf) => {
        const model = gltf.scene;
        loadedModel = model;
        model.traverse(n => {
          if (n.isMesh) {
            n.castShadow = false;
            n.receiveShadow = false;
            if (n.material) n.material.needsUpdate = true;
          }
        });

        scene.add(model);

        const box = new THREE.Box3().setFromObject(model);
        const size = box.getSize(new THREE.Vector3());
        modelCenter.copy(box.getCenter(new THREE.Vector3()));

        // recenter
        model.position.x += (model.position.x - modelCenter.x);
        model.position.y += (model.position.y - modelCenter.y);
        model.position.z += (model.position.z - modelCenter.z);

        const maxDim = Math.max(size.x, size.y, size.z);
        const fov = camera.fov * (Math.PI / 180);
        let cameraZ = Math.abs(maxDim / 2 / Math.tan(fov / 2));
        cameraZ *= 1.6;
        camera.position.set(modelCenter.x, modelCenter.y + maxDim * 0.35, modelCenter.z + cameraZ);
        camera.near = Math.max(0.01, cameraZ / 1000);
        camera.far = cameraZ * 10;
        camera.updateProjectionMatrix();
        controls.target.copy(modelCenter);
        controls.update();

        // position rect lights and their helpers now that center is known
        positionRectLights();
        updateDirTargets();
      },
      (xhr) => { if (xhr.lengthComputable) console.log(`Model ${(xhr.loaded/xhr.total*100).toFixed(1)}% loaded`); },
      (err) => { console.error('GLTF load error:', err); }
    );

    // --- GUI ---
    document.querySelectorAll('.lil-gui, .dg').forEach(e => e.remove());

    const params = {
      background: '#0b0b0b',
      shadows: false,
      doubleSided: true,
      showHelpers: false,
      axes: false,
      areaWidth: rectDefaults.width,
      areaHeight: rectDefaults.height,
      areaIntensity: rectDefaults.intensity,
      areaRadius: rectDefaults.radius,
      areaElevation: rectDefaults.elevation,
      // directional cluster options
      useDirectionalCluster: false,
      dirCount: 6,
      dirIntensity: 0.6,
      dirDistance: 5,
      dirElevation: 2.2,
      // exposure via buttons
      exposure: renderer.toneMappingExposure
    };

    const gui = new GUI({ width: 220 });
    gui.domElement.style.position = 'fixed';
    gui.domElement.style.right = '28px';
    gui.domElement.style.top = '28px';
    gui.domElement.style.zIndex = '10000';
    const defaultTitle = gui.domElement.querySelector('.title'); if (defaultTitle) defaultTitle.remove();

    gui.addColor(params, 'background').name('background').onChange(v => scene.background.set(v));
    gui.add(params, 'shadows').name('shadows').onChange(v => {
      renderer.shadowMap.enabled = !!v;
      if (loadedModel) loadedModel.traverse(n => { if (n.isMesh) { n.castShadow = !!v; n.receiveShadow = !!v; } });
    });

    gui.add(params, 'doubleSided').name('double sided').onChange(v => applyDoubleSided(v));

    gui.add(params, 'showHelpers').name('show light helpers').onChange(v => {
      if (v) {
        addRectHelpers();
        addDirHelpers();
      } else {
        removeRectHelpers();
        removeDirHelpers();
      }
    });

    gui.add(params, 'axes').name('show axes').onChange(v => { axes.visible = v; });

    const lightFolder = gui.addFolder('light');
    lightFolder.add(params, 'areaWidth', 0.2, 4.0, 0.01).name('area width').onChange(v => { rectLights.forEach(rl => rl.width = v); updateRectHelpersPositions(); positionRectLights(); });
    lightFolder.add(params, 'areaHeight', 0.2, 3.0, 0.01).name('area height').onChange(v => { rectLights.forEach(rl => rl.height = v); updateRectHelpersPositions(); positionRectLights(); });
    lightFolder.add(params, 'areaIntensity', 0, 40, 0.01).name('area intensity').onChange(v => { rectLights.forEach(rl => rl.intensity = v); });
    lightFolder.add(params, 'areaRadius', 0.2, 4.0, 0.01).name('radius').onChange(() => { positionRectLights(); updateRectHelpersPositions(); });
    lightFolder.add(params, 'areaElevation', -2.0, 6.0, 0.01).name('elevation').onChange(() => { positionRectLights(); updateRectHelpersPositions(); });
    lightFolder.close();

    const dirFolder = gui.addFolder('directional cluster');
    dirFolder.add(params, 'useDirectionalCluster').name('enable cluster').onChange(v => {
      if (v) {
        createDirectionalCluster(params.dirCount, params.dirIntensity, params.dirDistance, params.dirElevation);
        updateDirectionalPositions();
        if (params.showHelpers) addDirHelpers();
      } else {
        removeDirectionalCluster();
      }
    });
    dirFolder.add(params, 'dirCount', 2, 12, 1).name('count').onChange(v => { if (params.useDirectionalCluster) createDirectionalCluster(v, params.dirIntensity, params.dirDistance, params.dirElevation); });
    dirFolder.add(params, 'dirIntensity', 0, 4, 0.01).name('intensity').onChange(v => dirLights.forEach(dl => dl.intensity = v));
    dirFolder.add(params, 'dirDistance', 1, 15, 0.1).name('distance').onChange(v => updateDirectionalPositions());
    dirFolder.add(params, 'dirElevation', 0, 8, 0.1).name('elevation').onChange(v => updateDirectionalPositions());
    dirFolder.close();

    // exposure display + brighten/darken + flat preset
    const exposureDisplay = { exposureValue: params.exposure };
    gui.add(exposureDisplay, 'exposureValue').name('exposure').listen();

    const actions = {
      brighter: () => { params.exposure = Math.min(20.0, Math.round((params.exposure + 0.5) * 100) / 100); applyExposure(); },
      darker:  () => { params.exposure = Math.max(0.0, Math.round((params.exposure - 0.5) * 100) / 100); applyExposure(); },
      flat: () => {
        params.useDirectionalCluster = false;
        removeDirectionalCluster();
        // update GUI checkbox if present
        const c = dirFolder.__controllers.find(c => c.property === 'useDirectionalCluster');
        if (c) c.setValue(false);
        params.shadows = false;
        const sc = gui.__controllers.find(c => c.property === 'shadows');
        if (sc) sc.setValue(false);
        params.doubleSided = true;
        const dc = gui.__controllers.find(c => c.property === 'doubleSided');
        if (dc) dc.setValue(true);
        applyDoubleSided(true);
        params.areaIntensity = 30.0;
        lightFolder.__controllers.forEach(c => { if (c.property === 'areaIntensity') c.setValue(params.areaIntensity); });
        params.areaRadius = 0.6;
        lightFolder.__controllers.forEach(c => { if (c.property === 'areaRadius') c.setValue(params.areaRadius); });
        params.areaWidth = 3.6;
        lightFolder.__controllers.forEach(c => { if (c.property === 'areaWidth') c.setValue(params.areaWidth); });
        params.areaHeight = 1.8;
        lightFolder.__controllers.forEach(c => { if (c.property === 'areaHeight') c.setValue(params.areaHeight); });
        params.exposure = Math.min(20.0, 10.0);
        applyExposure();
        rectLights.forEach(rl => { rl.intensity = params.areaIntensity; rl.width = params.areaWidth; rl.height = params.areaHeight; });
        positionRectLights();
        // recreate helpers if on
        if (params.showHelpers) {
          removeRectHelpers(); addRectHelpers();
          removeDirHelpers(); // cluster disabled anyway
        }
      }
    };

    gui.add(actions, 'flat').name('flat even-lit');
    gui.add(actions, 'brighter').name('brighter +');
    gui.add(actions, 'darker').name('darker -');

    gui.domElement.querySelectorAll('.picker, .popup').forEach(el => el.style.zIndex = '11000');

    // --- Helpers management functions ---

    function addRectHelpers() {
      removeRectHelpers();
      rectLights.forEach((rl) => {
        const helperMat = new THREE.MeshBasicMaterial({ color: 0x99ffdd, opacity: 0.06, transparent: true, depthWrite: false });
        const helper = new THREE.Mesh(new THREE.PlaneGeometry(rl.width, rl.height), helperMat);
        helper.position.copy(rl.position);
        helper.lookAt(modelCenter);
        rectHelpers.push(helper);
        scene.add(helper);
      });
    }

    function removeRectHelpers() {
      rectHelpers.forEach(h => { if (h.parent) h.parent.remove(h); });
      rectHelpers.length = 0;
    }

    function updateRectHelpersPositions() {
      if (rectHelpers.length !== rectLights.length) return;
      for (let i = 0; i < rectLights.length; i++) {
        const rl = rectLights[i];
        const h = rectHelpers[i];
        h.geometry.dispose();
        h.geometry = new THREE.PlaneGeometry(rl.width, rl.height);
        h.position.copy(rl.position);
        h.lookAt(modelCenter);
      }
    }

    function addDirHelpers() {
      removeDirHelpers();
      // create arrow helpers that point from light -> modelCenter
      dirHelpers = [];
      dirLights.forEach(dl => {
        const dir = new THREE.Vector3().subVectors(modelCenter, dl.position).normalize();
        const length = dl.position.distanceTo(modelCenter) * 0.8; // arrow length shorter than distance
        const arrow = new THREE.ArrowHelper(dir, dl.position.clone(), length, 0xffcc88, 0.25, 0.12);
        dirHelpers.push(arrow);
        scene.add(arrow);
      });
    }

    function removeDirHelpers() {
      if (!dirHelpers || dirHelpers.length === 0) return;
      dirHelpers.forEach(h => { if (h.parent) h.parent.remove(h); if (h.line) h.line.geometry.dispose(); if (h.cone) h.cone.geometry.dispose(); });
      dirHelpers.length = 0;
    }

    function updateDirHelpersPositions() {
      if (!dirHelpers || dirHelpers.length !== dirLights.length) return;
      for (let i = 0; i < dirLights.length; i++) {
        const dl = dirLights[i];
        const h = dirHelpers[i];
        const dir = new THREE.Vector3().subVectors(modelCenter, dl.position).normalize();
        const length = dl.position.distanceTo(modelCenter) * 0.8;
        h.setDirection(dir);
        h.position.copy(dl.position);
        h.setLength(length, 0.25, 0.12);
      }
    }

    // --- Directional cluster position / helpers update ---
    function updateDirectionalPositions() {
      if (!dirLights || dirLights.length === 0) return;
      const count = dirLights.length;
      for (let i = 0; i < count; i++) {
        const a = (i / count) * Math.PI * 2;
        const x = Math.cos(a) * params.dirDistance;
        const z = Math.sin(a) * params.dirDistance;
        const y = params.dirElevation;
        dirLights[i].position.set(modelCenter.x + x, modelCenter.y + y, modelCenter.z + z);
        if (dirTargets[i]) dirTargets[i].position.set(modelCenter.x, modelCenter.y, modelCenter.z);
      }
      updateDirHelpersPositions();
    }

    function updateDirTargets() {
      if (!dirTargets || dirTargets.length === 0) return;
      dirTargets.forEach(t => t.position.set(modelCenter.x, modelCenter.y, modelCenter.z));
      updateDirectionalPositions();
    }

    // --- Utility: apply double-sided to model materials ---
    function applyDoubleSided(enabled) {
      if (!loadedModel) return;
      loadedModel.traverse(n => {
        if (n.isMesh && n.material) {
          n.material.side = enabled ? THREE.DoubleSide : THREE.FrontSide;
          n.material.needsUpdate = true;
        }
      });
    }

    // --- Area light positioning ---
    function positionRectLights() {
      const radius = params.areaRadius;
      const elevation = params.areaElevation;
      const angles = [0, Math.PI / 2, Math.PI, (3 * Math.PI) / 2];
      for (let i = 0; i < rectLights.length; i++) {
        const a = angles[i];
        const rl = rectLights[i];
        rl.width = params.areaWidth;
        rl.height = params.areaHeight;
        rl.intensity = params.areaIntensity;
        rl.position.set(
          modelCenter.x + Math.cos(a) * radius,
          modelCenter.y + elevation,
          modelCenter.z + Math.sin(a) * radius
        );
        rl.lookAt(modelCenter);
      }
      updateRectHelpersPositions();
      updateDirHelpersPositions();
    }

    // --- Exposure ---
    function applyExposure() {
      params.exposure = Math.min(20.0, Math.max(0.0, params.exposure));
      renderer.toneMappingExposure = params.exposure;
      ambient.intensity = Math.max(0.01, params.exposure * 0.7);
      const disp = gui.__controllers.find(c => c.property === 'exposureValue');
      if (disp) disp.object.exposureValue = params.exposure;
      if (loadedModel) loadedModel.traverse(n => { if (n.isMesh && n.material) n.material.needsUpdate = true; });
    }

    // --- Render loop ---
    function animate(now) {
      requestAnimationFrame(animate);
      // make sure rect lights and dir cluster follow GUI each frame
      rectLights.forEach(rl => { rl.intensity = params.areaIntensity; rl.width = params.areaWidth; rl.height = params.areaHeight; });
      positionRectLights();
      if (params.useDirectionalCluster && dirLights.length) {
        dirLights.forEach(dl => dl.intensity = params.dirIntensity);
        updateDirectionalPositions();
      }
      controls.update();
      renderer.render(scene, camera);
    }
    requestAnimationFrame(animate);

    // initial cleanup and apply stored state
    applyExposure();
    applyDoubleSided(params.doubleSided);
    removeDirectionalCluster(); // start without cluster by default

    // Resize handling
    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });
  </script>
</body>
</html>
