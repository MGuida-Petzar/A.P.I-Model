<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>A.P.I-Model â€” Studio Lighting + Custom GUI</title>
  <style>
    html,body { height:100%; margin:0; background:#0b0b0b; }
    canvas { display:block; width:100%; height:100vh; }

    /* Outer GUI card (Material-You inspired) */
    .lil-gui, .dg {
      position: fixed !important;
      right: 28px;
      top: 28px;
      width: 220px !important;
      max-width: 220px !important;
      border-radius: 14px;
      overflow: visible !important;
      background: rgba(18,18,18,0.85);
      box-shadow: 0 12px 30px rgba(2,6,23,0.6);
      border: 6px solid #f7b1a8; /* soft pink frame */
      z-index: 10000;
      padding: 8px 8px 12px 8px;
      font-family: "Roboto", system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
      color: #fff;
      -webkit-font-smoothing:antialiased;
      -moz-osx-font-smoothing:grayscale;
    }

    /* Hide default title */
    .lil-gui .title, .dg .title { display: none !important; }

    /* Pill controls */
    .lil-gui .controller, .dg .controller {
      margin: 8px 4px;
      padding: 6px 10px;
      border-radius: 12px;
      background: linear-gradient(180deg, rgba(67,93,82,0.22), rgba(49,71,60,0.12));
      box-shadow: inset 0 -2px 0 rgba(0,0,0,0.18);
      display: flex;
      align-items: center;
      justify-content: space-between;
      height: 38px;
    }

    .lil-gui .label, .dg .label {
      color: #f2f6f3;
      font-weight: 700;
      font-size: 14px;
      text-transform: lowercase;
      letter-spacing: -0.5px;
      margin-right: 8px;
    }

    .lil-gui input[type="range"] { accent-color: #66c2a4; }

    .lil-gui input[type="color"], .dg input[type="color"] {
      width: 30px;
      height: 26px;
      border-radius: 8px;
      border: none;
      box-shadow: 0 1px 0 rgba(0,0,0,0.25) inset;
      padding: 0;
      margin-left: 6px;
      background: transparent;
    }

    .lil-gui .boolean, .dg .boolean {
      display:flex;
      align-items:center;
      justify-content:flex-end;
      gap: 8px;
    }

    .lil-gui .picker, .lil-gui .popup, .dg .picker, .dg .popup {
      z-index: 11000 !important;
    }

    .lil-gui .folder, .dg .folder {
      margin: 6px 4px;
      padding: 6px 8px;
      border-radius: 10px;
      background: rgba(0,0,0,0.08);
    }

    body { padding: 12px; }
  </style>

  <script type="importmap">
  {
    "imports": {
      "three": "https://cdn.jsdelivr.net/npm/three@0.144.0/build/three.module.js"
    }
  }
  </script>
</head>
<body>
  <canvas id="canvas"></canvas>

  <script type="module">
    import * as THREE from 'three';
    import { GLTFLoader } from 'https://cdn.jsdelivr.net/npm/three@0.144.0/examples/jsm/loaders/GLTFLoader.js';
    import { OrbitControls } from 'https://cdn.jsdelivr.net/npm/three@0.144.0/examples/jsm/controls/OrbitControls.js';
    import { RectAreaLightUniformsLib } from 'https://cdn.jsdelivr.net/npm/three@0.144.0/examples/jsm/lights/RectAreaLightUniformsLib.js';
    import { RectAreaLightHelper } from 'https://cdn.jsdelivr.net/npm/three@0.144.0/examples/jsm/helpers/RectAreaLightHelper.js';
    import GUI from 'https://cdn.jsdelivr.net/npm/lil-gui@0.18.0/dist/lil-gui.esm.min.js';

    // --- Renderer & scene ---
    const canvas = document.getElementById('canvas');
    const renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
    renderer.setPixelRatio(window.devicePixelRatio || 1);
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.outputEncoding = THREE.sRGBEncoding;
    renderer.toneMapping = THREE.ACESFilmicToneMapping;
    renderer.toneMappingExposure = 1.0;
    renderer.shadowMap.enabled = true;
    renderer.shadowMap.type = THREE.PCFSoftShadowMap;

    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x0b0b0b);

    const camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.01, 1000);
    camera.position.set(0, 1.6, 3);
    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;

    // --- Lights ---
    const ambient = new THREE.AmbientLight(0xffffff, 0.25);
    scene.add(ambient);
    const hemi = new THREE.HemisphereLight(0xffffff, 0x111122, 0.15);
    scene.add(hemi);

    RectAreaLightUniformsLib.init();
    const keyLight = new THREE.RectAreaLight(0xffffff, 6.0, 2.6, 1.2);
    const fillLight = new THREE.RectAreaLight(0xffffff, 1.2, 2.2, 1.0);
    const rimLight = new THREE.RectAreaLight(0xffffff, 2.0, 1.6, 1.0);
    keyLight.castShadow = true;
    scene.add(keyLight, fillLight, rimLight);

    const dirLight = new THREE.DirectionalLight(0xffffff, 0.25);
    dirLight.position.set(5, 10, 7.5);
    dirLight.castShadow = true;
    dirLight.shadow.mapSize.set(2048, 2048);
    dirLight.shadow.camera.near = 0.5;
    dirLight.shadow.camera.far = 50;
    scene.add(dirLight);

    const keyHelper = new RectAreaLightHelper(keyLight);
    const fillHelper = new RectAreaLightHelper(fillLight);
    const rimHelper = new RectAreaLightHelper(rimLight);
    keyHelper.visible = false; fillHelper.visible = false; rimHelper.visible = false;
    scene.add(keyHelper, fillHelper, rimHelper);

    const axes = new THREE.AxesHelper(0.5);
    axes.visible = false;
    scene.add(axes);

    // --- Loader + model ---
    const loader = new GLTFLoader();
    // Updated model URL:
    const modelUrl = 'https://mguida-petzar.github.io/A.P.I-Model/new-folder/Project%20API.glb';

    let loadedModel = null;
    let modelCenter = new THREE.Vector3(0,0,0);

    loader.load(modelUrl,
      (gltf) => {
        const model = gltf.scene;
        loadedModel = model;
        model.traverse(n => {
          if (n.isMesh) { n.castShadow = true; n.receiveShadow = true; }
        });

        // default double sided applied when model loads (true)
        model.traverse(n => {
          if (n.isMesh && n.material) {
            n.material.side = THREE.DoubleSide;
            n.material.needsUpdate = true;
          }
        });

        scene.add(model);

        const box = new THREE.Box3().setFromObject(model);
        const size = box.getSize(new THREE.Vector3());
        modelCenter.copy(box.getCenter(new THREE.Vector3()));

        // recenter model
        model.position.x += (model.position.x - modelCenter.x);
        model.position.y += (model.position.y - modelCenter.y);
        model.position.z += (model.position.z - modelCenter.z);

        const maxDim = Math.max(size.x,size.y,size.z);
        const fov = camera.fov * (Math.PI/180);
        let cameraZ = Math.abs(maxDim/2 / Math.tan(fov/2));
        cameraZ *= 1.6;
        camera.position.set(modelCenter.x, modelCenter.y + maxDim*0.35, modelCenter.z + cameraZ);
        camera.near = Math.max(0.01, cameraZ/1000);
        camera.far = cameraZ*10;
        camera.updateProjectionMatrix();
        controls.target.copy(modelCenter);
        controls.update();

        // set initial light positions
        updateLightPositions(params.lightOrbit, params.lightRadius, params.lightElevation);
      },
      (xhr) => { if (xhr.lengthComputable) console.log(`Model ${(xhr.loaded/xhr.total*100).toFixed(1)}% loaded`); },
      (err) => { console.error('GLTF load error:', err); }
    );

    // Remove previous GUI DOM nodes (avoid duplicates)
    document.querySelectorAll('.lil-gui, .dg').forEach(e => e.remove());

    // --- GUI params (doubleSided default true) ---
    const params = {
      exposure: 1.0,
      background: '#0b0b0b',
      shadows: true,
      doubleSided: true,
      showHelpers: false,
      axes: false,
      // light orbit controls
      lightOrbit: 30,         // degrees (manual slider)
      lightRadius: 2.2,
      lightElevation: 1.6,
      // intensities
      keyIntensity: 6.0,
      fillIntensity: 1.2,
      rimIntensity: 2.0
    };

    // Rotation animation state
    let rotating = false;
    let rotateStart = 0;
    let rotateDuration = 0;
    let rotateFrom = 0;
    let rotateTo = 0;
    let rotateRAF = null;

    const gui = new GUI({ width: 220 });
    gui.domElement.style.position = 'fixed';
    gui.domElement.style.right = '28px';
    gui.domElement.style.top = '28px';
    gui.domElement.style.zIndex = '10000';
    const defaultTitle = gui.domElement.querySelector('.title'); if (defaultTitle) defaultTitle.remove();

    // Exposure
    gui.add(params, 'exposure', 0.1, 2.5, 0.01).name('exposure').onChange(v => {
      renderer.toneMappingExposure = v;
    });

    // Background color
    gui.addColor(params, 'background').name('background').onChange(v => {
      scene.background.set(v);
    });

    // Shadows toggle
    gui.add(params, 'shadows').name('shadows').onChange(v => {
      renderer.shadowMap.enabled = v;
    });

    // Double sided control
    gui.add(params, 'doubleSided').name('double sided').onChange(v => {
      if (!loadedModel) return;
      loadedModel.traverse(n => {
        if (n.isMesh && n.material) {
          n.material.side = v ? THREE.DoubleSide : THREE.FrontSide;
          n.material.needsUpdate = true;
        }
      });
    });

    // Helpers and axes
    gui.add(params, 'showHelpers').name('show light helpers').onChange(v => {
      keyHelper.visible = v;
      fillHelper.visible = v;
      rimHelper.visible = v;
    });
    gui.add(params, 'axes').name('show axes').onChange(v => {
      axes.visible = v;
    });

    // Light folder (bottom)
    const lightFolder = gui.addFolder('light');

    // Orbit slider (manual)
    const orbitController = lightFolder.add(params, 'lightOrbit', 0, 360, 1).name('light orbit').onChange(v => {
      updateLightPositions(v, params.lightRadius, params.lightElevation);
    });

    // Radius / elevation sliders
    lightFolder.add(params, 'lightRadius', 0.5, 6.0, 0.01).name('radius').onChange(v => {
      updateLightPositions(params.lightOrbit, v, params.lightElevation);
    });
    lightFolder.add(params, 'lightElevation', -2.0, 6.0, 0.01).name('elevation').onChange(v => {
      updateLightPositions(params.lightOrbit, params.lightRadius, v);
    });

    // Intensities
    lightFolder.add(params, 'keyIntensity', 0, 12, 0.01).name('key').onChange(v => keyLight.intensity = v);
    lightFolder.add(params, 'fillIntensity', 0, 6, 0.01).name('fill').onChange(v => fillLight.intensity = v);
    lightFolder.add(params, 'rimIntensity', 0, 8, 0.01).name('rim').onChange(v => rimLight.intensity = v);

    // Add Rotate 360 button + manual progress slider (like exposure)
    const controlActions = {
      rotate360: () => startRotation(5000), // default 5s full rotation
      stopRotation: () => stopRotation()
    };

    // rotation progress slider - mirrors params.lightOrbit
    gui.add(params, 'lightOrbit', 0, 360, 1).name('rotation').onChange(v => {
      updateLightPositions(v, params.lightRadius, params.lightElevation);
    });

    gui.add(controlActions, 'rotate360').name('rotate 360');
    gui.add(controlActions, 'stopRotation').name('stop');

    // Keep the light folder closed by default
    lightFolder.close();

    // Ensure popups above gui
    gui.domElement.querySelectorAll('.picker, .popup').forEach(el => el.style.zIndex = '11000');

    // --- Rotation animation functions ---
    function startRotation(durationMs = 5000) {
      if (rotating) {
        stopRotation();
      }
      rotating = true;
      rotateDuration = durationMs;
      rotateStart = performance.now();
      rotateFrom = params.lightOrbit % 360;
      rotateTo = rotateFrom + 360;
      rotateRAF = requestAnimationFrame(rotateStep);
    }

    function rotateStep(now) {
      const elapsed = now - rotateStart;
      const t = Math.min(1, elapsed / rotateDuration);
      const eased = t < 0.5 ? 2*t*t : -1 + (4 - 2*t)*t;
      const angle = rotateFrom + (rotateTo - rotateFrom) * eased;
      params.lightOrbit = angle % 360;
      // update GUI control display and lights
      orbitController.setValue(params.lightOrbit);
      updateLightPositions(params.lightOrbit, params.lightRadius, params.lightElevation);

      if (t < 1 && rotating) {
        rotateRAF = requestAnimationFrame(rotateStep);
      } else {
        rotating = false;
        rotateRAF = null;
      }
    }

    function stopRotation() {
      if (rotateRAF) cancelAnimationFrame(rotateRAF);
      rotating = false;
      rotateRAF = null;
    }

    // --- Light positioning helper ---
    function updateLightPositions(angleDeg = 0, radius = 2.2, elevation = 1.6) {
      const a = (angleDeg * Math.PI) / 180;
      keyLight.position.set(
        modelCenter.x + Math.cos(a) * radius,
        modelCenter.y + elevation,
        modelCenter.z + Math.sin(a) * radius
      );
      keyLight.lookAt(modelCenter);

      const aFill = a + Math.PI;
      fillLight.position.set(
        modelCenter.x + Math.cos(aFill) * (radius * 0.95),
        modelCenter.y + elevation * 0.85,
        modelCenter.z + Math.sin(aFill) * (radius * 0.95)
      );
      fillLight.lookAt(modelCenter);

      const aRim = a + Math.PI * 0.5;
      rimLight.position.set(
        modelCenter.x + Math.cos(aRim) * (radius * 1.1),
        modelCenter.y + elevation,
        modelCenter.z + Math.sin(aRim) * (radius * 1.1)
      );
      rimLight.lookAt(modelCenter);

      if (dirLight.target) {
        dirLight.target.position.set(modelCenter.x, modelCenter.y, modelCenter.z);
        scene.add(dirLight.target);
      }
    }

    // --- Render loop ---
    function animate() {
      requestAnimationFrame(animate);

      // Keep lights synchronized with GUI parameters every frame so slider always moves lights.
      updateLightPositions(params.lightOrbit, params.lightRadius, params.lightElevation);

      controls.update();
      renderer.render(scene, camera);
    }
    animate();

    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });
  </script>
</body>
</html>
